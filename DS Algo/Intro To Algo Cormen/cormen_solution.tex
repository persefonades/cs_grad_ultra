% cormen_solution.tex
\documentclass[fontsize=12pt,paper=a4,open=any]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx} 

\usepackage{xcolor}
\usepackage[linesnumbered,ruled]{algorithm2e}

\begin{document}
\title{Introduction to Algorithms - Solutions \\
\large 3rd Edition}
\author{Purbayan Chowdhury}

\maketitle

\tableofcontents

\chapter{The Role of Algorithms in Computing}

\chapter{Getting Started}
\section{Insertion Sort}

\begin{enumerate}
	\item[\textbf{Ex 2.1-1}]

	\item[\textbf{Ex 2.1-2}]
		\textbf{Rewrite the INSERTION-SORT procedure to sort into non-increasing instead of non-decreasing order.} \

	\item[A.]
		\begin{algorithm}[H]
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{A $\longleftarrow$ Unsorted\ Array}
			\Output{A $\longleftarrow$ Array\ Sorted\ in\ Non-increasing Order}

			\DontPrintSemicolon

			\For{$j \longleftarrow 1$ to $A.length-1$}
			{
				$key\longleftarrow A[j]$\;
				\tcc{Insert A[j] into the sorted sequence A[1..j-1]}
				$i \longleftarrow j-1$\;
				\While{$i \ge 0$ and $A[i] > key$}
				{
					$A[i+ 1] \longleftarrow A[i]$\;
					$i \longleftarrow i-1$\;
				}
				$A[i+ 1] \longleftarrow key$\;
			}

			\caption{Non-increasingInsertionSort}
		\end{algorithm}
	\item[\textbf{Ex 2.2-3}]
	
	\item[\textbf{Ex 2.2-4}]
		\textbf{Consider the searching problem:\
			Input: A sequence of n numbers $A =(a_1, a_2,\dots,a_n)$\
			Output: An index $i$ such that $v=A[i]$ or the special value NIL if $v$ does not appear in $A$.\
			Write pseudocode for linear search, which scans through the sequence, looking for $v$. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfils the three necessary properties.
		}
	
	\item[A.]
		\begin{algorithm}[H]
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{A $\longleftarrow$ Array\\
			v $\longleftarrow$ value to be searched}
			\Output{i $\longleftarrow$ index of the value if found, else NIL}

			\DontPrintSemicolon

			$i \longleftarrow NIL$\;
			\For{$j \longleftarrow 0$ to $A.length-1$}
			{
				\If{$A[j]=v$}
				{
					$i \longleftarrow j$\;
					break\;
				}
			}
			return $i$

			\caption{Linear-Search}
		\end{algorithm}

	\item[\textbf{Ex. 2.2-5}]
		\textbf{Consider the problem of adding two $n$-bit binary integers, stored in two n-element arrays $A$ and $B$. The sum of the two integers should be stored in binary form in an ($n+1$)-element array $C$. State the problem formally and write pseudocode for adding the two integers.}

	\item[A.]
		\begin{algorithm}[H]
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{A $\longleftarrow$ First Array\\
			B $\longleftarrow$ Second Array}
			\Output{C $\longleftarrow$ Binary Addition Result}

			\DontPrintSemicolon

			$carry \longleftarrow 0$\;
			\For{$i \longleftarrow n-1$ downto $0$}
			{
				$C[i+1] \longleftarrow (A[i] + B[i]+carry) (mod 2)$\;
				\If{$A[i] + B[i] + carry \ge 2$}
				{
					$carry \longleftarrow 1$\;
				}
				\Else
				{
					$carry \longleftarrow 0$\;
				}
			}
			$C[0] \longleftarrow carry$\;
			\caption{$n$-bitBinaryAddition}
		\end{algorithm}

\end{enumerate}

\section{Analyzing algorithms}
\begin{enumerate}
	\item[\textbf{Ex 2.2-1}]

	\item[\textbf{Ex 2.2-2}]
		\textbf{Consider sorting $n$ numbers stored in array $A$ by first finding the smallest element of $A$ and exchanging it with the element in $A[1]$. Then find the second smallest element of $A$, and exchange it with $A[2]$. Continue in this manner for the first $n-1$ elements of $A$. Write pseudocode for this algorithm, which is known as selection sort. What loop invariant does this algorithm maintain? Why does it need to run for only the first $n-1$ elements, rather than for all n elements? Give the best-case and worst-case running times of selection sort in $\Theta$-notation.}

	\item[A.]
		\begin{algorithm}[H]
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{A $\longleftarrow$ Unsorted Array}
			\Output{A $\longleftarrow$ Array Sorted in Increasing Order}

			\DontPrintSemicolon

			\For{$i \longleftarrow 0$ to $n-1$}
			{
				$min \longleftarrow i$\;
				\For{$j \longleftarrow i+1$ to $n$}
				{
					\tcc{Find the index of the ith smallest element}
					\If{$A[j] < A[min]$}
					{
						$min \longleftarrow j$\;
					}
				}
				Swap $A[min]$ and $A[i]$\;
			}
			\caption{SelectionSort}
		\end{algorithm}

			The loop invariant of selection sort is as follows:\\
			At each iteration of the for loop of lines 1 through 9, the subarray $A[0 \dots i-1]$ contains the $i-1$ smallest elements of $A$ in increasing order. After $n-1$ iterations of the loop, the $n-1$ smallest elements of $A$ are in the first $n-1$ positions of $A$ in increasing order so the nth element is necessarily the largest amount.\\
			The best-case and worst-case running times of selection sort are $\Theta(n^2)$, this is because regardless of how the elements are initially arranged, on the $i$-th iteration of the for loop in line 1, always inspects each of the remaining $n-i$ elements to find the smallest one remaining. \\
			This yields a running \\
			$\sum_{i=1}^{n-1} n-i = n(n-1) - \sum_{i=1}^{n-1} i = n^2-n-\frac{n^2-n}{2} = \frac{n^2-n}{2} = \Theta(n^2)$

		\item[\textbf{Ex 2.2-3}]

		\item[\textbf{Ex 2.2-4}]
\end{enumerate}

\chapter{Growth of Functions}

\end{document}
